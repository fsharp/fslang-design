## F# 4.0 Speclet: Make printf handle units of measure

[F# Language User Voice Entry](https://fslang.uservoice.com/forums/245727-f-language/suggestions/5752551-make-printf-handle-units-of-measure), [Pull Request](https://visualfsharp.codeplex.com/SourceControl/network/forks/dsyme/cleanup/contribution/7107), [Commit](https://github.com/dotnet/fsharp/commit/aa7e945db107d0baf8af8d39c2d82185213c2796)

### Background

Currently printf requires all numeric types with units of measure to have the units removed. For example:

    let years = 1<year> 
    printfn "%d" years // compile error 
    printfn "%d" (int years) // works

This gets quite ugly in code that uses units of measure heavily.

### Aim

Allow numeric values with units to be used as values when "%d", "%f" and other printf specifiers are used.

### Design

The F# Language Design includes a (under-documented) form of type constraint generated by uses of ``%d``, ``%f`` and so on in Printf format strings.
Internally, the 

    let inline f () = printfn "%d";;

which gives this type (which, coincidentally, can't be written in a signature file, nor entered as a type in user code - an instance of the so-called "type whose name cannot be spoken" problem):

    val inline f : unit -> ( ^a -> unit) when  ^a : (byte|int16|int32|int64|sbyte|uint16|uint32|uint64|nativeint|unativeint)

This type constraint is satisfied when ``^a`` is equal to one of the given types, before erasing unit-of-measure annotations.

The design is simply to change this equivalence check to ignore unit-of-measure annotations.

### Examples

    sprintf "%f" 1.0<meter>

            

