
# F# RFC FS-1003 - nameof Operator

The design suggestion [nameof operator](https://github.com/fsharp/fslang-suggestions/issues/252) has been marked "approved in principle".
This RFC covers the detailed proposal for this suggestion.

[Discussion thread](https://github.com/fsharp/FSharpLangDesign/issues/48)

* [x] Approved in principle
* [x] Details: [Resolved to Preview](https://github.com/fsharp/FSharpLangDesign/issues/48)
* [x] Implementation: [Complete to Preview](https://github.com/dotnet/fsharp/pull/6809), [Updates to Preview in Progress](https://github.com/dotnet/fsharp/pull/8754)

### Introduction

It's often useful to obtain the simple (unqualified) string name of a variable, type, or member. Today users end up writing something like this:

```fsharp
let add x y =
    if x < 0 then raise (ArgumentOutOfRangeException("x"))
    x + y
```

This RFC allows user code to extract the name of a declaration, like:

```fsharp
let add x y =
    if x < 0 then raise (ArgumentOutOfRangeException(nameof(x))
    x + y
```

The construct may also be used as a pattern:

```fsharp
type MyEvent =
    | A of string
    | B of string

let deserialize (tag: string) (data: string) : MyEvent =
    match tag with
    | nameof A -> A data
    | nameof B -> B data
    | t -> failwithf "Invalid EventType: %s" t
```


### Design Principles

The design principles for F# `nameof` are as follows.

1. For `nameof(text)` to resolve to a symbol, then `text` must resolve to the same symbol if used in a normal way at that point in the source code.  

2. To whatever extent possible, `nameof(M)` must be robust under rename-refactor of symbol `M` in typical F# tooling. That necessitates `M` carrying enough information to give a precise symbol resolution down to a specific member, value, function, namespace etc. 

3. Where possible, as little new logic must be added to the design of F#. It is better from both cognitive (ease-of-learning) and implementation perspectives to minimise the new logic and rules.

4. The feature should be simple and easy to use.

5. The feature should align with other F# language features.

6. The feature should otherwise be similar to the corresponding C# feature.

NOTE: These design principles vary from C#.  For example:

1. `nameof(M)` in C# can resolve to an instance member.  F# doesn't support unqualified resolution of instance members, so a dummy `this` argument is needed, e.g. `nameof(Unchecked.defaultof<C>.M)` or `nameof(this.M)` etc.

2. `nameof(M)` in C# doesn't need annotation for an overloaded member. This results in ambiguity when `M` is renamed.  In F# additional information must be added to identify the precise member, so that if renaming occurs the symbol is accurately renamed.

## Syntax

There are two forms of `nameof` syntactically:

```fsharp
nameof x // 'nameof(x)' as well, parentheses required to disambiguate as with other functions

nameof<'Type>
```

The first form is the most common, for taking names of anything that isn't a type parameter.

The second form is for taking the name of a type parameter. This follows the same syntax as other operators like `typeof<_>` and `typedefof<_>`.

### Detailed Processing Rules for `nameof expr`

A library function `FSharp.Core.Operators.nameof` is added.  When used we adjust the processing of the expression form

```fsharp
nameof expr
```

Here `expr` is syntactically an expression and is processed as follows:

1. If `expr` is of the form `(expr2)` then the parentheses are ignored and `expr` is processed

2. If `expr` is of the form `expr2 : type` then `type` is processed and `expr2` is processed using the resulting known type

3. If `expr` is a long  identifier e.g. `id1.id2.id3` then it is resolved as either

   a. a long identifier expression (excluding type names or type applications, and using any available known type from a type annotation), or

   b. a type name or type application, or
   
   c. a namespace or module

The exact symbol resolution is recorded by the F# compiler and made available to F# tooling for rename-refactor, symbol search and other interactions.

### Naming 

The name of the operator is `nameof`. It is an intrinsic in FSharp.Core.

### Scope of use

- can be used with method parameters

- can be used with local variables

- can be used with local (nested) functions

- can be used with local curried functions

- can be used with local tupled functions

- can be used with provided symbol names, i.e. generated by type providers

- can be used from inside a local function (needs to be let rec)

- can be used with member names

- can be used with static member names

- can be used with static property names

- can be used with names that are quoted in <code>``</code>

- can be used with names of operators like `+`, `|>`, `typeof`, `nameof`, evaluating to the compiled name of the operator

- can be used with generic functions/types

- can be used in attributes

- can be used with namespaces, `nameof(System.Diagnostics)`

- can be used with type names, `nameof(System.String)`

- can be used with module names, `nameof(FSharp.Collections.List)`

Other considerations:

- the use of `nameof` is allowed in quotations, the substitution is still made at compile-time

- the text `nameof` may resolve to something user-defined (this avoids a breaking change)

- `nameof` may not used like a first-class function value, `let f = nameof ;; f x`

- `nameof` may not be used with pipe operator, `x |> nameof`

- `nameof` does not perform "forward lookup", such as taking the name of a parameter to a method or function in an argument that decorates it

### Names of instance members

Names of members must be static or come from an instance. So the following code that attempts to get the name of an instance property with an instance of its containing class is not valid:

```fsharp
type C() =
    member _.M = ()

nameof C.M // Error!
```

But the following are valid::

```fsharp
type C() =
    static member M = ()
    member _.M2 = ()

nameof C.M // Yay :)

let c = C()
nameof c.M2 // Yay :)

nameof Unchecked.defaultof<C>.M2 // Yay :)
```

This is an intentional divergence from the C# design, where you can take a name of an instance member without an instance. This requirement for an instance is also present when constructing quotations in F#, and in general is consistent with how the compiler resolves names and how that surfaces to the user. The design opts for consistency over a special kind of name resolution in this case.

### Names of overloaded members require a type annotation

When selecting an overloaded member, a type annotation may be necessary to select a precise member:
```fsharp

type MethodGroupNameOfTests() =
    member this.MethodGroup() = ()    
    member this.MethodGroup(i:int) = ()

    member this.MethodGroup1(i:int, f:float, s:string) = 0
    member this.MethodGroup1(f:float, l:int64) = "foo"
    member this.MethodGroup1(u:unit -> unit -> int, h: unit) : unit = ()

    member this.``single argument method group name lookup`` () =
        let b = nameof(this.MethodGroup)
        Assert.AreEqual("MethodGroup",b)

    member this.``multiple argument method group name lookup`` () =
        let b = nameof(this.MethodGroup1 : (float * int64 -> _))
        Assert.AreEqual("MethodGroup1",b)
```

This is intentional and in keeping with how selecting the correct overload for F# very often requires a type annotation.

### Names of operators reveal the name of the symbol in source

Operators are tricky constructs in F#, since their compiled name is very different from their name in source. Ultimately, we felt that the name of the operator as it is in source is a more accurate name for the feature.

```fsharp
nameof(+)   // gives "+"
```

That said, you can also take a name of the compiled name of the same operator. If you do that, then the compiled name is revaled:

```fsharp

nameof(op_Addition)   // gives "op_Addition"
```

### Names of generic type instantiations are permitted

The `nameof` construct can be used with generic type instantiations, e.g.

```fsharp
type C2<'T> = A | B
type C3<'T>() = class end

nameof(C2)      // gives "C2"
nameof(C2<int>) // gives "C2"
nameof(C2<_>)   // gives "C2"
nameof(C3)      // gives "C3"
nameof(C3<_>)   // gives "C3"
```

### `nameof` on generic type parameters is permitted when the type parameter is in scope

When a generic type parameter is in scope, you can take its name:

```fsharp
type C<'TTT> =
    let nm = nameof<'TTT>
    
    static member GetName() = nameof<'TTT>
```

Note that the syntax is different: it is `nameof<'TTT>` and not `nameof 'TTT`. This is intentional and consistent with processing generic type names in other FSharp.Core intrinsic operators like `typeof` and `typedefof`.

### `nameof` of a function using `RequiresExplicitTypeArguments` may require explicit type parameters

F# functions labeled with the `RequiresExplicitTypeArguments` require the use of a dummy type instantiation:

```fsharp
nameof(typeof<_>)
```

This attribute is used very rarely, so it is unlikely to come up

### Literals

From a design standpoint, it is permitted to use `nameof` in a literal like so:

```fsharp
let rec [<Literal>] SomeTag = nameof SomeTag

module rec M =
    let [<Literal>] OtherTag = nameof OtherTag
```

However, this is not possible in the current implementation due to deficiences in processing literal values recursively. The work for this is tracked in the following language suggestion: https://github.com/fsharp/fslang-suggestions/issues/889

## Alternatives

See also unresolved issues below.

### Alternative: formalize the notion of a named entity and specialize its name resolution

In the [C# version of this feature](https://github.com/dotnet/csharplang/blob/master/spec/expressions.md#nameof-expressions), the `nameof` expression takes a `named_entity` as input. A named entity is a valid expression, with one key distinction: instance members that fail to resolve due to being in a static context **do not** fail to resolve when in the context of a `nameof` expression. It is also an error for a named entity designating a method group to have type arguments.

For F#, we have instead adopted the principle that, like in F# quotations, enough information should be given to specify a precise symbol resolution, rather than adding this new concept to the language definition just for this one feature.

Further, F# doesn't support unqualified resolution of instance members, and it would be unnatural and complexifying to add that capability here.

This could be revisited in the future, though it's worth noting that the amount of work required to enable this specific scenario would be very high relative to the overall benefit of no requiring an instance. Given this, it is unlikely that we will revisit this design.

#### Alternative: use a keyword not a library intrinsic

This would have been a breaking change.

## Unresolved issues

None
